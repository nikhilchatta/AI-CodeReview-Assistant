name: AI Code Review Gate

# Reusable workflow â€” called by ai-review.yml in any target repository.

on:
  workflow_call:
    inputs:
      max_files:
        description: Maximum number of changed files to send for review
        type: number
        default: 20
      file_extensions:
        description: Comma-separated file extensions to include (e.g. .py,.ts,.scala)
        type: string
        default: .py,.ts,.tsx,.js,.jsx,.scala,.sql,.tf
      timeout_minutes:
        description: Maximum minutes the review job is allowed to run
        type: number
        default: 30
    secrets:
      AI_AGENT_API_URL:
        required: true
        description: Base URL of the AI agent backend (e.g. http://1.2.3.4)
      AI_AGENT_API_KEY:
        required: true
        description: API key for authenticating with the AI agent backend

jobs:
  ai-code-review-gate:
    name: AI Code Review Gate
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}
    permissions:
      contents: read
      pull-requests: write

    steps:

      # â”€â”€ Step 1: Verify backend is reachable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verify backend connectivity
        env:
          API_URL: ${{ secrets.AI_AGENT_API_URL }}
          API_KEY: ${{ secrets.AI_AGENT_API_KEY }}
        run: |
          # Strip any accidental whitespace/newlines from secrets
          API_URL=$(printf '%s' "${API_URL}" | tr -d '\r\n' | xargs)
          API_KEY=$(printf '%s' "${API_KEY}" | tr -d '\r\n' | xargs)

          echo "Checking ${API_URL}/api/health ..."
          HTTP_STATUS=$(curl -sf --max-time 15 \
            -o /tmp/health.json -w "%{http_code}" \
            -H "x-api-key: ${API_KEY}" \
            "${API_URL}/api/health")
          echo "Health status: ${HTTP_STATUS}"
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "::error::Backend not reachable (HTTP ${HTTP_STATUS}). Check AI_AGENT_API_URL secret."
            cat /tmp/health.json 2>/dev/null || true
            exit 1
          fi
          cat /tmp/health.json

      # â”€â”€ Step 2: Checkout PR code with full history for diff â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      # â”€â”€ Step 3: Compute changed files from PR diff â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Compute changed files
        id: diff
        env:
          BASE_REF:    ${{ github.base_ref }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          MAX_FILES:   ${{ inputs.max_files }}
          EXTENSIONS:  ${{ inputs.file_extensions }}
        run: |
          git fetch origin "${BASE_REF}"
          DIFF_HEAD="${PR_HEAD_SHA:-HEAD}"
          echo "Diff: origin/${BASE_REF}...${DIFF_HEAD}"

          PATTERNS=$(echo "$EXTENSIONS" | tr ',' '\n' | sed 's/^\./\*./g' | tr '\n' ' ')
          FILES=$(git diff --name-only --diff-filter=ACMRT \
            "origin/${BASE_REF}...${DIFF_HEAD}" \
            -- $PATTERNS 2>/dev/null | head -n "$MAX_FILES")

          if [ -z "$FILES" ]; then
            echo "no_files=true" >> "$GITHUB_OUTPUT"
            echo "No matching files changed â€” skipping AI review."
          else
            echo "no_files=false" >> "$GITHUB_OUTPUT"
            FILE_COUNT=$(echo "$FILES" | wc -l | tr -d ' ')
            echo "file_count=${FILE_COUNT}" >> "$GITHUB_OUTPUT"
            echo "$FILES" > /tmp/changed_files.txt
            echo "Files to review (${FILE_COUNT}):"
            cat /tmp/changed_files.txt
          fi

      # â”€â”€ Step 4: Skip when no reviewable files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Skip â€” no reviewable files changed
        if: steps.diff.outputs.no_files == 'true'
        run: |
          echo "No files matching [${{ inputs.file_extensions }}] were changed."
          echo "AI code review gate skipped â€” nothing to review."

      # â”€â”€ Step 5: Build JSON payload from changed files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Build review payload
        id: payload
        if: steps.diff.outputs.no_files == 'false'
        env:
          PR_NUMBER:  ${{ github.event.pull_request.number }}
          REPO:       ${{ github.repository }}
          HEAD_REF:   ${{ github.head_ref }}
          BASE_REF:   ${{ github.base_ref }}
          COMMIT_SHA: ${{ github.sha }}
          ACTOR:      ${{ github.actor }}
          RUN_ID:     ${{ github.run_id }}
        run: |
          FILES_JSON='[]'

          while IFS= read -r fpath; do
            full="${GITHUB_WORKSPACE}/${fpath}"
            [ -f "$full" ] || { echo "[skip] not found: ${fpath}"; continue; }

            ext="${fpath##*.}"
            case "$ext" in
              py)       lang="python"     ;;
              pyspark)  lang="pyspark"    ;;
              ts|tsx)   lang="typescript" ;;
              js|jsx)   lang="javascript" ;;
              scala)    lang="scala"      ;;
              sql)      lang="sql"        ;;
              tf)       lang="terraform"  ;;
              *)        echo "[skip] unknown ext: ${fpath}"; continue ;;
            esac

            # Truncate to 100 KB and write to temp file (jq --rawfile handles escaping)
            head -c 102400 "$full" > /tmp/file_content.tmp

            FILE_OBJ=$(jq -n \
              --rawfile content /tmp/file_content.tmp \
              --arg path     "$fpath" \
              --arg language "$lang" \
              '{"path": $path, "content": $content, "language": $language}')

            FILES_JSON=$(printf '%s' "$FILES_JSON" | jq --argjson obj "$FILE_OBJ" '. + [$obj]')
            echo "[payload] added ${fpath} (${lang})"
          done < /tmp/changed_files.txt

          FILE_COUNT=$(printf '%s' "$FILES_JSON" | jq 'length')
          echo "Total files in payload: ${FILE_COUNT}"

          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "no_files=true" >> "$GITHUB_OUTPUT"
            echo "::warning::No readable files after filtering."
            exit 0
          fi

          PROJECT=$(echo "$REPO" | cut -d/ -f2)

          jq -n \
            --argjson files     "$FILES_JSON" \
            --arg     repo      "$REPO" \
            --argjson pr_num    "${PR_NUMBER:-0}" \
            --arg     branch    "$HEAD_REF" \
            --arg     base_br   "$BASE_REF" \
            --arg     sha       "$COMMIT_SHA" \
            --arg     actor     "$ACTOR" \
            --arg     run_id    "$RUN_ID" \
            --arg     project   "$PROJECT" \
            '{
              files:         $files,
              analysis_type: "review",
              metadata: {
                repository:      $repo,
                pr_number:       $pr_num,
                branch:          $branch,
                base_branch:     $base_br,
                commit_sha:      $sha,
                actor:           $actor,
                workflow_run_id: $run_id,
                project_id:      $project
              }
            }' > /tmp/review_payload.json

          echo "Payload size: $(wc -c < /tmp/review_payload.json) bytes"
          jq '{files: [.files[] | .path]}' /tmp/review_payload.json

      # â”€â”€ Step 6: Call /api/review/pr â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Run AI review
        id: review
        if: steps.diff.outputs.no_files == 'false' && steps.payload.outputs.no_files != 'true'
        env:
          API_URL: ${{ secrets.AI_AGENT_API_URL }}
          API_KEY: ${{ secrets.AI_AGENT_API_KEY }}
        run: |
          # Strip newlines â€” this was the root cause of all prior failures
          API_URL=$(printf '%s' "${API_URL}" | tr -d '\r\n' | xargs)
          API_KEY=$(printf '%s' "${API_KEY}" | tr -d '\r\n' | xargs)

          echo "POSTing payload to ${API_URL}/api/review/pr ..."
          HTTP_STATUS=$(curl -s --max-time 300 \
            -o /tmp/review_response.json -w "%{http_code}" \
            -X POST "${API_URL}/api/review/pr" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${API_KEY}" \
            --data-binary @/tmp/review_payload.json)

          echo "HTTP status: ${HTTP_STATUS}"

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "::error::Review API returned HTTP ${HTTP_STATUS}"
            cat /tmp/review_response.json
            echo "gate_status=fail" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          # Extract and write step outputs using jq
          GATE=$(jq -r '.gate_status // "pass"' /tmp/review_response.json)
          ISSUES=$(jq -r '.total_issues // 0' /tmp/review_response.json)
          CRITICAL=$(jq -r '.severity_breakdown.critical // 0' /tmp/review_response.json)

          echo "gate_status=${GATE}"   >> "$GITHUB_OUTPUT"
          echo "total_issues=${ISSUES}"   >> "$GITHUB_OUTPUT"
          echo "critical_count=${CRITICAL}" >> "$GITHUB_OUTPUT"

          echo "Gate: ${GATE} | Issues: ${ISSUES} | Critical: ${CRITICAL}"
          jq '{gate_status, total_issues, severity_breakdown, model, cost_usd, latency_ms}' \
            /tmp/review_response.json

      # â”€â”€ Step 7: Post PR comment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Post PR comment
        if: steps.diff.outputs.no_files == 'false' && steps.payload.outputs.no_files != 'true'
        env:
          GH_TOKEN:  ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          GATE=$(jq -r '.gate_status // "pass"'    /tmp/review_response.json)
          ISSUES=$(jq -r '.total_issues // 0'      /tmp/review_response.json)
          FILES_REV=$(jq -r '.files_reviewed // 0' /tmp/review_response.json)
          CRIT=$(jq -r '.severity_breakdown.critical // 0' /tmp/review_response.json)
          HIGH=$(jq -r '.severity_breakdown.high    // 0' /tmp/review_response.json)
          MED=$(jq -r '.severity_breakdown.medium   // 0' /tmp/review_response.json)
          LOW=$(jq -r '.severity_breakdown.low      // 0' /tmp/review_response.json)
          INFO=$(jq -r '.severity_breakdown.info    // 0' /tmp/review_response.json)
          MODEL=$(jq -r '.model    // ""'  /tmp/review_response.json)
          TOKENS=$(jq -r '.token_usage.total_tokens // 0' /tmp/review_response.json)
          COST=$(jq -r '.cost_usd // 0'   /tmp/review_response.json)
          RUN_ID=$(jq -r '.run_id // ""'  /tmp/review_response.json)

          if [ "$GATE" = "pass" ]; then
            HEADER="## âœ… AI Code Review â€” PASSED"
          else
            HEADER="## âŒ AI Code Review â€” FAILED"
          fi

          # Build comment markdown into a file
          {
            echo "$HEADER"
            echo ""
            echo "**Gate:** \`${GATE^^}\` | **Issues:** ${ISSUES} | **Files reviewed:** ${FILES_REV}"
            echo ""
            echo "| Severity | Critical | High | Medium | Low | Info |"
            echo "|----------|:--------:|:----:|:------:|:---:|:----:|"
            echo "| Count    | ${CRIT}  | ${HIGH} | ${MED} | ${LOW} | ${INFO} |"

            # Validation failures
            VAL_COUNT=$(jq '.validation_failures | length' /tmp/review_response.json)
            if [ "$VAL_COUNT" -gt 0 ]; then
              echo ""
              echo "### Validation Failures (pattern rules)"
              jq -r '.validation_failures[:25][] |
                "- **[\(.severity | ascii_upcase)]** `\(.category)` â€” \(.message)\n  ðŸ“ `\(.file)\(if .line_number then ":\(.line_number)" else "" end)`\(if .suggestion then "\n  > ðŸ’¡ \(.suggestion)" else "" end)"
              ' /tmp/review_response.json
              if [ "$VAL_COUNT" -gt 25 ]; then
                echo "- *â€¦and $((VAL_COUNT - 25)) more validation failures*"
              fi
            fi

            # LLM findings
            LLM_COUNT=$(jq '.llm_findings | length' /tmp/review_response.json)
            if [ "$LLM_COUNT" -gt 0 ]; then
              echo ""
              echo "### AI Findings"
              jq -r '.llm_findings[:25][] |
                "- **[\(.severity | ascii_upcase)]** `\(.category)` â€” \(.message)\n  ðŸ“ `\(.file)\(if .line_number then ":\(.line_number)" else "" end)`\(if .suggestion then "\n  > ðŸ’¡ \(.suggestion)" else "" end)"
              ' /tmp/review_response.json
              if [ "$LLM_COUNT" -gt 25 ]; then
                echo "- *â€¦and $((LLM_COUNT - 25)) more AI findings*"
              fi
            fi

            if [ "$VAL_COUNT" -eq 0 ] && [ "$LLM_COUNT" -eq 0 ]; then
              echo ""
              echo "*No issues found. Great work! ðŸŽ‰*"
            fi

            echo ""
            echo "<sub>Model: \`${MODEL}\` | Tokens: ${TOKENS} | Cost: \$${COST} | Run: \`${RUN_ID}\`</sub>"
          } > /tmp/pr_comment.md

          gh pr comment "$PR_NUMBER" --body-file /tmp/pr_comment.md

      # â”€â”€ Step 8: Record metrics for observability dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Record metrics
        if: always() && steps.diff.outputs.no_files == 'false' && steps.payload.outputs.no_files != 'true' && steps.review.outputs.gate_status != ''
        env:
          API_URL:    ${{ secrets.AI_AGENT_API_URL }}
          API_KEY:    ${{ secrets.AI_AGENT_API_KEY }}
          REPO:       ${{ github.repository }}
          HEAD_REF:   ${{ github.head_ref }}
          PR_NUMBER:  ${{ github.event.pull_request.number }}
          ACTOR:      ${{ github.actor }}
          COMMIT_SHA: ${{ github.sha }}
          RUN_ID:     ${{ github.run_id }}
        run: |
          API_URL=$(printf '%s' "${API_URL}" | tr -d '\r\n' | xargs)
          API_KEY=$(printf '%s' "${API_KEY}" | tr -d '\r\n' | xargs)
          PROJECT=$(echo "$REPO" | cut -d/ -f2)

          # Read values from review response (may not exist if review step failed)
          GATE=$(jq -r      '.gate_status                   // "fail"'    /tmp/review_response.json 2>/dev/null || echo "fail")
          STATUS=$(jq -r    '.status                        // "failure"' /tmp/review_response.json 2>/dev/null || echo "failure")
          ISSUES=$(jq -r    '.total_issues                  // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          CRIT=$(jq -r      '.severity_breakdown.critical   // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          HIGH=$(jq -r      '.severity_breakdown.high       // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          MED=$(jq -r       '.severity_breakdown.medium     // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          LOW=$(jq -r       '.severity_breakdown.low        // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          FILES_REV=$(jq -r '.files_reviewed                // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          TOK_IN=$(jq -r    '.token_usage.input_tokens      // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          TOK_OUT=$(jq -r   '.token_usage.output_tokens     // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          TOK_TOT=$(jq -r   '.token_usage.total_tokens      // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          COST=$(jq -r      '.cost_usd                      // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          MODEL=$(jq -r     '.model                         // ""'        /tmp/review_response.json 2>/dev/null || echo "")
          LATENCY=$(jq -r   '.latency_ms                    // 0'         /tmp/review_response.json 2>/dev/null || echo 0)
          TIMESTAMP=$(jq -r '.timestamp                     // ""'        /tmp/review_response.json 2>/dev/null || echo "")
          RUN_ID_FULL=$(jq -r '.run_id                      // ""'        /tmp/review_response.json 2>/dev/null || echo "$RUN_ID")

          # â”€â”€ POST /api/metrics/ingest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          jq -n \
            --arg  repo       "$REPO" \
            --arg  project    "$PROJECT" \
            --arg  run_id     "$RUN_ID" \
            --arg  timestamp  "$TIMESTAMP" \
            --arg  status     "$STATUS" \
            --arg  model      "$MODEL" \
            --arg  branch     "$HEAD_REF" \
            --arg  actor      "$ACTOR" \
            --argjson pr_num  "${PR_NUMBER:-0}" \
            --argjson tok_in  "$TOK_IN" \
            --argjson tok_out "$TOK_OUT" \
            --argjson tok_tot "$TOK_TOT" \
            --argjson latency "$LATENCY" \
            --argjson files   "$FILES_REV" \
            --argjson issues  "$ISSUES" \
            --argjson crit    "$CRIT" \
            --argjson high    "$HIGH" \
            --argjson cost    "$COST" \
            '{
              repository:      $repo,
              project_id:      $project,
              workflow_run_id: $run_id,
              timestamp:       $timestamp,
              request_count:   1,
              input_tokens:    $tok_in,
              output_tokens:   $tok_out,
              total_tokens:    $tok_tot,
              latency_ms:      $latency,
              status:          $status,
              files_reviewed:  $files,
              issues_found:    $issues,
              critical_count:  $crit,
              high_count:      $high,
              model:           $model,
              cost_usd:        $cost,
              pr_number:       $pr_num,
              branch:          $branch,
              triggered_by:    $actor,
              source:          "pipeline"
            }' > /tmp/metrics_payload.json

          MS_STATUS=$(curl -s --max-time 30 \
            -o /tmp/metrics_response.json -w "%{http_code}" \
            -X POST "${API_URL}/api/metrics/ingest" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${API_KEY}" \
            --data-binary @/tmp/metrics_payload.json)
          echo "Metrics ingest HTTP ${MS_STATUS}"
          METRIC_ID=$(jq -r '.id // ""' /tmp/metrics_response.json 2>/dev/null || echo "")

          # â”€â”€ POST /api/metrics/runs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          VAL_FAILS=$(jq '.validation_failures // []' /tmp/review_response.json 2>/dev/null || echo '[]')
          LLM_FINDS=$(jq '.llm_findings        // []' /tmp/review_response.json 2>/dev/null || echo '[]')
          PER_FILE=$(jq  '.per_file_results    // []' /tmp/review_response.json 2>/dev/null || echo '[]')
          SEVERITY=$(jq  '.severity_breakdown  // {}' /tmp/review_response.json 2>/dev/null || echo '{}')
          BASE_REF="${{ github.base_ref }}"
          SHA="${COMMIT_SHA}"

          jq -n \
            --arg  run_id_full  "$RUN_ID_FULL" \
            --arg  metric_id    "$METRIC_ID" \
            --arg  repo         "$REPO" \
            --arg  sha          "$SHA" \
            --arg  actor        "$ACTOR" \
            --arg  branch       "$HEAD_REF" \
            --arg  base_br      "$BASE_REF" \
            --arg  run_id       "$RUN_ID" \
            --arg  project      "$PROJECT" \
            --arg  gate         "$GATE" \
            --arg  status       "$STATUS" \
            --arg  model        "$MODEL" \
            --arg  timestamp    "$TIMESTAMP" \
            --argjson pr_num    "${PR_NUMBER:-0}" \
            --argjson val_fails "$VAL_FAILS" \
            --argjson llm_finds "$LLM_FINDS" \
            --argjson per_file  "$PER_FILE" \
            --argjson severity  "$SEVERITY" \
            --argjson issues    "$ISSUES" \
            --argjson crit      "$CRIT" \
            --argjson high      "$HIGH" \
            --argjson med       "$MED" \
            --argjson low       "$LOW" \
            --argjson files     "$FILES_REV" \
            --argjson tok_in    "$TOK_IN" \
            --argjson tok_out   "$TOK_OUT" \
            --argjson tok_tot   "$TOK_TOT" \
            --argjson cost      "$COST" \
            --argjson latency   "$LATENCY" \
            '{
              run_id:               $run_id_full,
              metric_id:            (if $metric_id == "" then null else $metric_id end),
              repository:           $repo,
              pr_number:            $pr_num,
              commit_sha:           $sha,
              actor:                $actor,
              branch:               $branch,
              base_branch:          $base_br,
              workflow_run_id:      $run_id,
              project_id:           $project,
              gate_status:          $gate,
              status:               $status,
              validation_failures:  $val_fails,
              llm_findings:         $llm_finds,
              per_file_results:     $per_file,
              severity_distribution: $severity,
              total_issues:         $issues,
              critical_count:       $crit,
              high_count:           $high,
              medium_count:         $med,
              low_count:            $low,
              files_reviewed:       $files,
              input_tokens:         $tok_in,
              output_tokens:        $tok_out,
              total_tokens:         $tok_tot,
              cost_usd:             $cost,
              model:                $model,
              latency_ms:           $latency,
              timestamp:            $timestamp,
              runtime_ms:           $latency,
              source:               "pipeline"
            }' > /tmp/run_detail_payload.json

          RD_STATUS=$(curl -s --max-time 30 \
            -o /tmp/run_detail_response.json -w "%{http_code}" \
            -X POST "${API_URL}/api/metrics/runs" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${API_KEY}" \
            --data-binary @/tmp/run_detail_payload.json)
          echo "Run detail HTTP ${RD_STATUS}"

      # â”€â”€ Step 9: Enforce gate result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: AI Code Review Gate
        if: always() && steps.diff.outputs.no_files == 'false'
        run: |
          GATE="${{ steps.review.outputs.gate_status }}"
          ISSUES="${{ steps.review.outputs.total_issues }}"
          CRIT="${{ steps.review.outputs.critical_count }}"

          echo "Gate:     ${GATE:-unknown}"
          echo "Issues:   ${ISSUES:-0}"
          echo "Critical: ${CRIT:-0}"

          if [ "${GATE}" != "pass" ]; then
            echo "::error::AI Code Review gate FAILED (${ISSUES} issue(s), ${CRIT} critical). Fix the reported issues before merging."
            exit 1
          fi
          echo "AI Code Review gate PASSED."
